{% extends "base.html" %}

{% block title %}Match #{{ match.id }}{% endblock %}

{% block content %}
<div class="dealer-section">
    <div class="boxes-label">
        Match #{{ match.id }}
    </div>

    <div class="hand-container">
        <div class="hand-header">Dealer</div>
        <div id="dealerCards" class="card-row"></div>
        <div id="dealerStatus" class="hand-value"></div>
    </div>
</div>

<div class="boxes-section">
    <div class="box-container">
        <div class="hand-container">
            <div class="hand-header">You</div>
            <div id="playerCards" class="card-row"></div>
            <div id="playerStatus" class="hand-value"></div>
        </div>
    </div>
</div>

<div style="margin-top: 18px; text-align: center;">
    <div id="actionButtons"></div>
</div>

<div style="margin-top: 18px;">
    <div class="boxes-label">Log</div>
    <div id="logBox" style="height:160px; overflow:auto; border:1px solid #1e5030; background:#0a2010; padding:10px; border-radius:10px;"></div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Safe for JavaScript:
    const MATCH_ID = {{ match.id | tojson }};
    const USER_ID  = {{ current_user.id | tojson }};

    let state = null;
    let pollTimer = null;

    function el(id) { return document.getElementById(id); }

    function log(msg) {
        const box = el('logBox');
        if (!box) return;
        const line = document.createElement('div');
        line.textContent = msg;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }

    function renderCards(container, cards) {
        if (!container) return;
        container.innerHTML = '';
        if (!cards) return;

        for (const c of cards) {
            const div = document.createElement('div');

            // Your CSS uses .card-back, but your old code used "back".
            // We'll set both to be safe.
            const isBack = !!c.hidden;
            div.className = 'card' + (isBack ? ' card-back back' : '');

            div.textContent = isBack ? 'ðŸ‚ ' : (c.rank + c.suit);
            container.appendChild(div);
        }
    }

    function setStatus(elem, txt) {
        if (!elem) return;
        elem.textContent = txt || '';
    }

    function clearActions() {
        const a = el('actionButtons');
        if (!a) return;
        a.innerHTML = '';
    }

    function addBtn(label, endpoint, payload=null, cls='btn') {
        const area = el('actionButtons');
        if (!area) return;

        const b = document.createElement('button');
        b.className = cls;
        b.textContent = label;

        b.onclick = async () => {
            try {
                await callAction(endpoint, payload);
            } catch (e) {
                console.error(e);
                log("ERROR: " + (e && e.message ? e.message : String(e)));
            }
        };

        area.appendChild(b);
    }

    async function callAction(endpoint, payload=null) {
        const opts = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        };
        if (payload) opts.body = JSON.stringify(payload);

        const r = await fetch(`/game/${MATCH_ID}/${endpoint}`, opts);

        if (!r.ok) {
            const t = await r.text();
            throw new Error(t || ("HTTP " + r.status));
        }

        state = await r.json();
        renderState();
    }

    function renderState() {
        if (!state) return;

        renderCards(el('dealerCards'), state.dealer_cards);
        renderCards(el('playerCards'), state.player_cards);

        setStatus(el('dealerStatus'), state.dealer_status_text);
        setStatus(el('playerStatus'), state.player_status_text);

        clearActions();

        // -----------------------------
        // FLOW ACTIONS
        // -----------------------------
        if (state.can_start) {
            addBtn('Start', 'start', null, 'btn primary');
        }
        if (state.can_draw) {
            addBtn('Hit', 'action', { action: 'hit' });
        }
        if (state.can_stand) {
            addBtn('Stand', 'action', { action: 'stand' });
        }

        // -----------------------------
        // CHOICE
        // -----------------------------
        if (state.can_choice && state.choice_options) {
            for (const opt of state.choice_options) {
                addBtn(opt.label, 'choice', { goes_first: opt.value });
            }
        }

        // -----------------------------
        // BETTING
        // -----------------------------
        if (state.can_bet && state.bet_options) {
            for (const b of state.bet_options) {
                addBtn('Bet ' + b, 'bet', { bets: [b] });
            }
        }

        // -----------------------------
        // INSURANCE
        // -----------------------------
        if (state.can_insurance && state.insurance_options) {
            for (const opt of state.insurance_options) {
                addBtn(opt.label, 'insurance', { decisions: [opt.value] });
            }
        }

        // -----------------------------
        // DEALER ACTION
        // -----------------------------
        if (state.can_dealer_action) {
            addBtn('Dealer Action', 'dealer_action');
        }

        // -----------------------------
        // JOKER
        // -----------------------------
        if (state.can_joker) {
            addBtn('Assign Joker', 'joker', { values: [] });
        }
        if (state.can_dealer_joker) {
            addBtn('Dealer Joker', 'dealer_joker', { values: [] });
        }

        // -----------------------------
        // NEXT ROUND
        // -----------------------------
        if (state.can_next) {
            addBtn('Next', 'next', null, 'btn primary');
        }
        if (state.can_timeout) {
            addBtn('Timeout', 'timeout', null, 'btn danger');
        }

        if (state.message) log(state.message);
        if (state.error) log("ERROR: " + state.error);
    }

    async function fetchState() {
        try {
            const r = await fetch(`/game/${MATCH_ID}/state`);
            if (!r.ok) return;
            state = await r.json();
            renderState();
        } catch (e) {
            console.error(e);
        }
    }

    function startPolling() {
        if (pollTimer) clearInterval(pollTimer);
        pollTimer = setInterval(fetchState, 1200);
        fetchState();
    }

    startPolling();
</script>
{% endblock %}
